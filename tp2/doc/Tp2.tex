% Facultad de Ingenier\'ia, Universidad de Buenos Aires
% 75.59 Técnicas de Programación Concurrente I

\documentclass[a4paper,12pt,titlepage]{article}
\usepackage[paperwidth=180mm,paperheight=285mm,left=1.5cm,top=4cm,right=1.5cm,bottom=2cm,head=2.0cm,includefoot]{geometry}
\usepackage[spanish]{babel}
%\usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}
\usepackage{lscape}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{rotating}
%\graphicspath{{../}}

\usepackage{listingsutf8}

\title{75.59 Técnicas de Programación Concurrente I, Trabajo Práctico 2}
\author{Torres, Miguel \and Montoya, Diego \and Garay, Ignacio}

\lhead{\includegraphics[scale=0.06]{./logo_fiuba.pdf}}
\chead{ 75.59 Técnicas de Programación Concurrente I }
\rhead{}

\lfoot{Garay - Montoya - Torres}
\rfoot{\thepage}
\cfoot{$2^{do}$ Cuatrimestre 2013}

\begin{document}

\thispagestyle{empty}
% T\'itulo del documento.
\begin{center}
\includegraphics{./logo-fiuba.png}\\
\vspace{1cm}
\textsc{\LARGE Universidad de Buenos Aires}\\[0.3cm]
\textsc{\LARGE Facultad de Ingenier\'ia}\\[1.2cm]
\textsc{\Large 75.59 - Técnicas de Programación Concurrente I}\\[0.3cm]
\end{center}

\begin{flushright}
{\large
Montoya, Diego -- 91939\\
Torres, Miguel -- 91396\\
Garay, Ignacio -- 92265\\
\vspace{2cm}
$2^{do}$ cuatrimestre de 2013}
\end{flushright}

\pagestyle{fancy}
\setcounter{page}{1}
\newpage

\tableofcontents
\newpage

\footnotesize
\section{Análisis}
En el análisis del trabajo se identificaron las siguientes identidades del dominio:\\
\begin{itemize}
\item Cliente
\item Servidor
\item Receptor de Clientes
\item Resolvedor de Paquetes\\
\end{itemize} 

El Servidor es la clase que inicia todos los recursos necesarios para una tener una conversación, creando además
al Receptor de Clientes y al Resolvedor de Paquetes. El Servidor además es el encargado de de gestionar las 
conversaciones, permitiendo agregar nuevas y administrando las ya existentes.

Cuando un Cliente es iniciado, es el Recibidor de Clientes es el encargado de capturar la solicitud de inicio de sesión para luego comunicarsela al Resolvedor, 
dejando todo listo para que el Cliente pueda crear una nueva conversación o unirse a una existente.

Una vez que algunos clientes forman parte de la misma conversación, los mensajes entre ellos enviados son capturados
por el Receptor de Mensajes perteneciente a cada cliente, el cual se encarga de enviar dichos mensajes al Resolvedor y este las distribuye a las conversaciones correspondientes.

Puede verse entonces que el Cliente actúa como productor de mensajes, los cuales son consumidos por el Receptor de Mensajes y este a la vez es un productor de paquetes que estos son consumidos por el Resolvedor.\\

\subsection{Casos de Uso}
Se identificaron además los siguientes casos de uso, desde el punto de vista del usuario:\\
\begin{figure}[h!]
\centering
\includegraphics[width=0.6\textwidth]{CasosDeUso.png}
\caption{Diagrama de casos de uso del Cliente}
\label{fig:casos_uso}
\end{figure}

\begin{itemize}
\item \textbf{Crear una conversación}\\ 
  Es el caso de uso en el cual un Cliente conectado al Servidor decide iniciar una nueva conversación, en la cual inicialmente
  será el único miembro, hasta que otro Cliente decida unirse para conversar
\item \textbf{Consultar conversaciones}\\
  Es el caso de uso en el cual el Cliente conectado al Servidor decide realizar una consulta sobre las conversaciones
  existentes actualmente en el Servidor
\item \textbf{Unirse a una conversación}\\
  Es el caso de uso en el cual un Cliente luego de consultar las conversaciones existentes en el Servidor decide además
  unirse a una de ellas\\
\end{itemize} 


\newpage
\section{Diseño}

Para la resolución de la concurrencia en la aplicacion se implementaron varias herramientas como Fifo, Pipe, Lock , 
Memoria Compartida, Señales y Sockets.

Se crearon los siguientes procesos, uno encargado de la generacion de los recursos y administración de las conversaciones, llamado 
appServidor, este último es el encargado de crear el proceso llamados appReceptor, encargado de recibir los paquetes enviados por un cliente.\\

Por último existe el proceso llamado appCliente, el cual es creado cuando un usuario inicia un Cliente y le permite interactuar con
el Servidor para unirse a una conversación o iniciar una nueva.\\

Para la comunicacion entre cliente y servidor se decidio hacerla mediante Sockets UDP ya que facitilan la comunicaion a un mismo socket desde otros sockets en distintos procesos ya que nunca se mantiene una conexion, en cambio no es asi con Sockets TCP. Se decidio por usar sockets y no otro mecanismo de comunicacion para tener practica sobre metodos de comunicacion para entornos distruibos, ya que la aplicacion puede portada a funcionar en mas de una PC.

\subsection{Servidor}

Dentro del proceso appServidor se crean 2 nuevos procesos llamados Resolvedor y Recibidor que se encargar de resolver todas la solicitudes y recibir nuevos clientes respectivamente.
El funcionamiento del servidor es el siguiente, cuando un cliente intenta conectarse este le envia un paquete de inicio de sesion(a travez de una conexion UDP), que este paquete es luego captado por el proceso Recibidor que crea un nuevo proceso Receptor para ese cliente, luego se retransmitira el paquete y algunos datos mas de conexion al proceso Resolvedor y al nuevo Receptor (utilizando un area de memoria compartida). Luego el recibidor espera una confirmacion(mediante un semaforo) del proceso Receptor para poder seguir escuchando nuevos usuarios.\\

La tarea que lleva a cabo el proceso resolvedor es guardar almacenar todos los usuarios en linea, todas las conversaciones abiertas y de reenviar todos los mensajes que se envien entre si. Para ello cuando arriba un paquete a la Cola de Paquetes (un area de memoria compartida para colocar los paquetes de los usuarios que iniciaron sesion) este lo retira de alli, mira que tipo de paquete es, resuelve la peticion correspondiente y le envia la respuesta al usuario o a todos los integrantes dentro de una conversacion si se tratase de un mensaje. Este procedimiento se repite hasta que el proceso padre le envie una señal de finalización.\\

Cuando llega una solicitud de inicio de sesion al Resolvedor, este es informado de la situacion mendiante una señal que es enviada por el proceso Recibidor. La tarea que se lleva a cabo es la siguiente, se lee la informacion de usuario (paquete y datos de conexion) que fueron colocadas por el Recibidor (en un area de memoria compartida). Cuando obtiene el paquete lo procesa(crea el nuevo usuario si no existe) y si no hubo problemas se le envia una señal de confirmación al proceso Receptor para que prosiga con su correcta ejecucion, en cambio si otro usuario habia iniciado sesion con el mismo nombre se emite un error y se le indica al Receptor que finalice, informando sobre este error al usuario. Luego de realizar todo esto el proceso Resolvedor finaliza el tratamiento de la señal y continua con su normal ejecución.\\

\subsection{Paquete}

Los paquetes utilizados en toda la aplicacion se diseñaron para resolver varios problemas (como iniciar y finalizar sesion, crear y unirse a una conversacion, mensajes, etc) y asi resolverlos todos contenidos en una misma estructura.
Se pensaron para que sean de tamanio fijo, de 512 bytes concretamente, conformando la siguiente estructura:

\begin{itemize}
\item Cabecera: 2 bytes en formato Big Endian para el tamanio del paquete, 1 byte para el tipo de paquete y 1 ultimo byte para la cantidad de atributos.
\item Datos: 508 bytes disponibles para datos(o tambien llamados atributos).\\
\end{itemize}

Segun el tipo de paquete que sea se resuelve una solicitud diferente. Los diferentes tipos de paquetes son los siguientes:
\begin{itemize}
\item INICIO\_SESION: indica que un usuario intenta inciar sesion.
\item FIN\_SESION: indica que un usuario desea finalizar su sesion.
\item MENSAJE: contiene el mensaje que envio un usuario, en la conversacion donde se encuentra.
\item CREAR\_CONVERSACION: indica que un usuario quiere crear una converasacion.
\item UNIRSE\_CONVERSACION indica que un usuario desea unirse a una conversacion ya creada.
\item CONVERSACIONES: indica una solicitud para que ver las conversaciones disponibles.
\item OK: indica una confirmacion sobre algun evento por parte del servidor ( inicio y fin de sesion, etc).
\item ERROR: indica un error ocurrido cuando se proceso una solitud de un usuario.
\item DESCONOCIDO: identifica al paquete como desconocido y no se lo puede procesar.

\end{itemize}

\subsection{Sistema de Log}

Se implemento el mismo sistema de log que en primer proyecto, el cual divide los sucesos en diferentes categorías, las cuales son:
\begin{itemize}
\item Info: informacion corriente de los pasos de la ejecucion.
\item Debug: informacion de debug.
\item Fatal: indica una excepcion lanzada.
\item Warning: informacion de advertencia sobre algun comportamiento anormal.
\item Error: indica un error critico en la aplicacion
\end{itemize}
El archivo de salida de Log esta resguardado por un Lock para su correcta escritura por los distintos procesos que vuelcan su información.

\newpage
\section{Diagramas}
\subsection{Diagrama de Comunicacion}
En el siguiente diagrama se puede ver como es la forma comunicaion de un usuario con la ya dentro de una conversacion, enviando y recibiendo mensajes.
\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{dia_comunicacion.png}
\caption{Diagrama de comunicacion entre procesos}
\label{fig:comunicacion}
\end{figure}

\newpage
\subsection{Diagrama de Clases}
Diagrama de clases con Objetos mas importantes del Servidor, solo hay un objeto Singleton por proceso, describiendo la relacion con los otros objetos utilizados para la comunicacion entre ellos. 
\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{dia_clases-servidor.png}
\caption{Diagrama de clases del Servidor con los mecanismos IPCs más representativos}
\label{fig:clases}
\end{figure}

El diagrama de clases de un cliente no es relevante ya que solo constaria de una unica clase.

\subsection{Diagrama de Estados}
Diagrama de transcion de estados para un cliente.
\begin{figure}[h!]
\centering
\includegraphics[width=0.7\textwidth]{dia_estados_cliente.png}
\caption{Diagrama de Estados de un cliente.}
\label{fig:estados}
\end{figure}

\newpage
\section{Integración}

Para la recibir los mensajes de los distintos usuarios se implemento una Cola de Paquetes que utiliza internamente un segmento de Memoria Compartida y 3 semaforos (uno para sacar, otro para insertar y otro para leer/escribir del segmento de memoria). Esta Cola es instanciada por el proceso Resolvedor y por todos los procesos Receptor (1 por cada usuario en conectado).\\

Para enviar la informacion de un nuevo usuario a los otros procesos por parte del Recibidor se implemento una clase llamada AreaDeIntercambio que utiliza un segmento de memoria compartida en donde se guarda informacion del nuevo usuario, como el nombre del nuevo usuario, el PID del proceso Receptor que gestionara los paquetes enviados por ese usuario y datos sobre la direccion UDP del socket del cliente.\\

Para sincronizar entre todos los procesos involucrados en el inicio de sesion de un nuevo usuario se utilizaron semaforos. Un semaforo es utilizado por el Resolvedor cuando este modifica sus estrucutas internas y al momento de enviar los paquetes de respuesta a los distintos usuarios, por lo que antes de enviar la señal de un nuevo usuario el recibidor hace un wait() del semaforo para asegurar que no pongo en riesgo nunca elemento interno del resolvedor. Otro semaforo es utilizado por el un receptor y el resolvedor al momento de crear un nuevo usuario donde el wait() lo hace el resolvedor esperando que inicie correctamente el Recepetor y se que en estado de espera para la confirmacion de continuar(en caso de positivo o negativo del inicio de sesion del usuario). Cuando el Receptor recibe la confirmacion de continuar, para ambos escenarios(inicio correctamente sesion o se produjo un error), este envia un signal() al Recibidor, que previamente realizo un wait() luego de enviar la señal al Resolvedor, para que continue en la escucha de nuevos usuarios.\\

Un cliente solo consta de dos procesos(una vez establecida la conexion con el servidor) donde uno se encargar de enviar paquetes y el otro recibir las respuestas. El emisor envia paquetes segun lo ingresado por entrada estandar y el receptor imprime por salida estadar los paquetes que le llegan.

\end{document}

